<GROUP_BY_programmers_A>

* GROUP BY
15/16
1. 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기
- 아래 방법으로는 안되는지 시도해봤지만 안됐음.
  검색해보니 내가 원하는 방식은 없는 것 같음.
SELECT CAR_TYPE , COUNT(CAR_TYPE) AS CARS 
FROM CAR_RENTAL_COMPANY_CAR
WHERE OPTIONS IN ('%통풍시트%' , '%열선시트%' , '%가죽시트%')
GROUP BY CAR_TYPE
Order by CAR_TYPE;



- 최종 답안
SELECT  CAR_TYPE, COUNT (CAR_TYPE) AS  CARS
FROM  CAR_RENTAL_COMPANY_CAR 
WHERE  OPTIONS LIKE '%시트%'
GROUP  BY  CAR_TYPE
ORDER  BY  CAR_TYPE;





2. 고양이와 개는 몇 마리 있을까
SELECT ANIMAL_TYPE  , COUNT(ANIMAL_TYPE ) AS COUNT
FROM ANIMAL_INS  
GROUP BY ANIMAL_TYPE 
Order by ANIMAL_TYPE ;





3. 동명 동물 수 찾기
SELECT NAME , COUNT(NAME) AS COUNT
FROM ANIMAL_INS
GROUP BY NAME
HAVING COUNT(NAME) >= 2
Order by NAME;





4. 입양 시각 구하기(1)
SELECT HOUR(DATETIME) AS HOUR , 
COUNT(DATETIME) AS COUNT
FROM ANIMAL_OUTS  
WHERE HOUR(DATETIME) >= 9 AND HOUR(DATETIME) < 20
GROUP BY HOUR(DATETIME)
Order by HOUR(DATETIME);





5. 성분으로 구분한 아이스크림 총 주문량
SELECT T2.INGREDIENT_TYPE , SUM(T1.TOTAL_ORDER) AS TOTAL_ORDER
FROM FIRST_HALF  T1
INNER JOIN ICECREAM_INFO T2
ON T1.FLAVOR = T2.FLAVOR
GROUP BY T2.INGREDIENT_TYPE
Order by T1.TOTAL_ORDER;





6. 즐겨찾기가 가장 많은 식당 정보 출력하기
- 아래 방법으로 풀어보고싶었는데 일식만 출력이 안되는 문제를 해결하지 못했음.
SELECT FOOD_TYPE , REST_ID , REST_NAME , FAVORITES
FROM REST_INFO
GROUP BY FOOD_TYPE
HAVING FAVORITES = MAX(FAVORITES)
Order by FOOD_TYPE DESC;



- 새로운 문법 답안
SELECT  FOOD_TYPE, REST_ID, REST_NAME, FAVORITES
FROM  REST_INFO
WHERE  (FOOD_TYPE, FAVORITES) 
IN  
( SELECT  FOOD_TYPE, MAX (FAVORITES)
FROM  REST_INFO
GROUP  BY  FOOD_TYPE )
ORDER  BY  FOOD_TYPE DESC



- 서브 쿼리 활용 답안
SELECT FOOD_TYPE , REST_ID , REST_NAME , FAVORITES
from rest_info
WHERE FOOD_TYPE IN(SELECT FOOD_TYPE FROM rest_info
GROUP BY FOOD_TYPE
HAVING FAVORITES = MAX(FAVORITES))
Order by FOOD_TYPE DESC





7. 조건에 맞는 사용자와 총 거래금액 조회하기
SELECT T1.WRITER_ID AS USER_ID , T2.NICKNAME , SUM(T1.PRICE) AS TOTAL_SALES
FROM USED_GOODS_BOARD T1

INNER JOIN USED_GOODS_USER T2
ON T1.WRITER_ID = T2.USER_ID
WHERE STATUS = 'DONE'
GROUP BY T1.WRITER_ID
HAVING SUM(T1.PRICE) >= 700000

ORDER BY TOTAL_SALES;



SUM(T2.SALES) AS TOTAL_SALES

8. 카테고리 별 도서 판매량 집계하기
SELECT T1.CATEGORY , SUM(T2.SALES) AS TOTAL_SALES
FROM BOOK T1

INNER JOIN BOOK_SALES T2
ON T1.BOOK_ID = T2.BOOK_ID
WHERE YEAR(T2.SALES_DATE) = 2022 AND MONTH(T2.SALES_DATE) = 1
GROUP BY T1.CATEGORY

Order by T1.CATEGORY;





9. 진료과별 총 예약 횟수 출력하기
SELECT MCDP_CD AS 진료과코드 , COUNT(APNT_NO) AS 5월예약건수
FROM APPOINTMENT

WHERE YEAR(APNT_YMD) = 2022 AND MONTH(APNT_YMD) = 5
GROUP BY MCDP_CD

Order by COUNT(APNT_NO) , MCDP_CD;





10. 저자 별 카테고리 별 매출액 집계하기
SELECT AUTHOR_ID , AUTHOR_NAME , CATEGORY , 
SUM(SALES * PRICE) AS TOTAL_SALES
FROM BOOK T1

INNER JOIN BOOK_SALES T3 USING(BOOK_ID)
INNER JOIN AUTHOR T2 USING(AUTHOR_ID)

WHERE YEAR(T3.SALES_DATE) = 2022 AND MONTH(T3.SALES_DATE) = 1
GROUP BY AUTHOR_ID , CATEGORY

Order by AUTHOR_ID , CATEGORY DESC;





11. 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기
SELECT CAR_ID , 
CASE WHEN CAR_ID IN(SELECT CAR_ID FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE '2022-10-16' BETWEEN START_DATE AND END_DATE)
THEN '대여중'
ELSE '대여 가능' END 'AVAILABILITY'
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY 

GROUP BY CAR_ID

ORDER BY CAR_ID DESC;





12. 식품분류별 가장 비싼 식품의 정보 조회하기
SELECT CATEGORY , PRICE AS MAX_PRICE , PRODUCT_NAME
FROM FOOD_PRODUCT 

WHERE PRICE IN(
SELECT MAX(PRICE) FROM FOOD_PRODUCT
GROUP BY CATEGORY)
HAVING CATEGORY IN('과자', '국', '김치', '식용유')

ORDER BY PRICE DESC;





13. 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기
SELECT MONTH(START_DATE) AS MONTH , CAR_ID , COUNT(HISTORY_ID) AS RECORDS
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY

WHERE CAR_ID IN(
SELECT CAR_ID FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY 
WHERE DATE_FORMAT(START_DATE , '%Y-%m') BETWEEN '2022-08' AND '2022-10'
GROUP BY CAR_ID
HAVING COUNT(CAR_ID) >= 5
)
AND DATE_FORMAT(START_DATE , '%Y-%m') BETWEEN '2022-08' AND '2022-10'
GROUP BY MONTH , CAR_ID
HAVING RECORDS > 0

ORDER BY MONTH , CAR_ID DESC;





14. 가격대 별 상품 개수 구하기
SELECT TRUNCATE(PRICE , -4) AS PRICE_GROUP , COUNT(PRODUCT_ID) AS PRODUCTS
FROM PRODUCT 

GROUP BY PRICE_GROUP

ORDER BY PRICE_GROUP





15. 년, 월, 성별 별 상품 구매 회원 수 구하기
SELECT YEAR(O.SALES_DATE) AS YEAR , MONTH(O.SALES_DATE) AS MONTH , U.GENDER , COUNT(DISTINCT U.USER_ID) AS USERS
FROM ONLINE_SALE  O

INNER JOIN USER_INFO U
USING(USER_ID)
WHERE GENDER IS NOT NULL
GROUP BY YEAR , MONTH , GENDER

ORDER BY YEAR , MONTH , GENDER